using Android;
using Android.App;
using Android.Content;
using Android.Content.PM;
using Android.Content.Res;
using Android.Graphics;
using Android.Hardware.Camera2;
using Android.Hardware.Camera2.Params;
using Android.Media;
using Android.OS;
using Android.Util;
using Android.Views;
using Android.Widget;
using AndroidX.AppCompat.App;
using AndroidX.Core.App;
using AndroidX.Core.Content;
using Bumptech.Glide;
using ClipperA.Listeners;
using Java.Lang;
using Java.Util;
using System.Collections.Generic;
using System.Threading;
using Boolean = Java.Lang.Boolean;

namespace ClipperA
{
    [Activity(Label = "Camera", ScreenOrientation = Android.Content.PM.ScreenOrientation.Portrait)]
    public class CameraActivity : AppCompatActivity
    {
        private static readonly SparseIntArray ORIENTATIONS = new SparseIntArray();
        public static readonly int REQUEST_CAMERA_Permission = 1;
        private static readonly string FRAGMENT_DIALOG = "dialog";

        // Tag for the {@link Log}.
        private static readonly string TAG = "ClipperAFragment";

        // Camera state: Showing camera preview.
        public const int STATE_PREVIEW = 0;
        // Camera state: Waiting for the focus to be locked.
        public const int STATE_WAITING_LOCK = 1;
        // Camera state: Waiting for the exposure to be precapture state.
        public const int STATE_WAITING_PRECAPTURE = 2;
        //Camera state: Waiting for the exposure state to be something other than precapture.
        public const int STATE_WAITING_NON_PRECAPTURE = 3;
        // Camera state: Picture was taken.
        public const int STATE_PICTURE_TAKEN = 4;

        // Max preview width that is guaranteed by Camera2 API
        private static readonly int MAX_PREVIEW_WIDTH = 1920;
        // Max preview height that is guaranteed by Camera2 API
        private static readonly int MAX_PREVIEW_HEIGHT = 1080;

        // TextureView.ISurfaceTextureListener handles several lifecycle events on a TextureView
        private ClipperASurfaceTextureListener mSurfaceTextureListener;

        // ID of the current {@link CameraDevice}.
        private string mCameraId;


        private string targetCamera = "0";
        private int camerasCount;

        private bool fullScreenSize = false;

        // An AutoFitTextureView for camera preview
        private AutoFitTextureView mTextureView;
        private ImageView mImageView;

        private ImageButton takePictureBtn;
        //  private ImageButton chengeOrientationBtn;
        private ImageButton flashBtn;
        private ImageButton rotateBtn;
        private ImageButton acceptBtn;
        private ImageButton discardBtn;

        private ManualResetEvent mre = new ManualResetEvent(false);
        // A {@link CameraCaptureSession } for camera preview.
        public CameraCaptureSession mCaptureSession;

        // A reference to the opened CameraDevice
        public CameraDevice mCameraDevice;

        // The size of the camera preview
        private Size mPreviewSize;

        // CameraDevice.StateListener is called when a CameraDevice changes its state
        private CameraStateListener mStateCallback;

        // An additional thread for running tasks that shouldn't block the UI.
        private HandlerThread mBackgroundThread;
        // A {@link Handler} for running tasks in the background.
        public Handler mBackgroundHandler;

        // An {@link ImageReader} that handles still image capture.
        private ImageReader mImageReader;

        // This a callback object for the {@link ImageReader}. "onImageAvailable" will be called when a
        // still image is ready to be saved.
        private ImageAvailableListener mOnImageAvailableListener;

        //{@link CaptureRequest.Builder} for the camera preview
        public CaptureRequest.Builder mPreviewRequestBuilder;

        // {@link CaptureRequest} generated by {@link #mPreviewRequestBuilder}
        public CaptureRequest mPreviewRequest;

        // The current state of camera state for taking pictures.
        public int mState = STATE_PREVIEW;

        // A {@link Semaphore} to prevent the app from exiting before closing the camera.
        public Semaphore mCameraOpenCloseLock = new Semaphore(1, 2);

        // Whether the current camera device supports Flash or not.
        private bool mFlashSupported;

        private enum FlashMode
        {
            Off,
            On,
            Auto
        }
        private FlashMode mFlashMode;

        // Orientation of the camera sensor
        private SensorOrientationListener mOrientationListener;
        public ImageOrientation mSensorOrientation { get; set; }
        public bool isFaceCamera { get; private set; } = false;
       // public int mSensorOrientation { get; private set; }

        // A {@link CameraCaptureSession.CaptureCallback} that handles events related to JPEG capture.
        public CameraCaptureListener mCaptureCallback;

        protected override void OnCreate(Bundle savedInstanceState)
        {
            base.OnCreate(savedInstanceState);
            // Intent intent = new Intent(MediaStore.ActionImageCapture);


            if (ContextCompat.CheckSelfPermission(this, Manifest.Permission.Camera) != (int)Permission.Granted)
            {
                ActivityCompat.RequestPermissions(this, new string[] { Manifest.Permission.Camera }, 200);
            }
            else
            {
                mStateCallback = new CameraStateListener(this);
                mSurfaceTextureListener = new ClipperASurfaceTextureListener(this);

                // fill ORIENTATIONS list
                ORIENTATIONS.Append((int)SurfaceOrientation.Rotation0, 90);
                ORIENTATIONS.Append((int)SurfaceOrientation.Rotation90, 0);
                ORIENTATIONS.Append((int)SurfaceOrientation.Rotation180, 270);
                ORIENTATIONS.Append((int)SurfaceOrientation.Rotation270, 180);

                SetContentView(Resource.Layout.TakingPicture);

                mTextureView = (AutoFitTextureView)FindViewById(Resource.Id.texture);
                mImageView = FindViewById<ImageView>(Resource.Id.image);


                takePictureBtn = FindViewById<ImageButton>(Resource.Id.takePictureBtn);
                flashBtn = FindViewById<ImageButton>(Resource.Id.flashBtn);
                rotateBtn = FindViewById<ImageButton>(Resource.Id.rotateBtn);

                acceptBtn = FindViewById<ImageButton>(Resource.Id.doneBtn); 
                discardBtn = FindViewById<ImageButton>(Resource.Id.clearBtn); 

                takePictureBtn.Click += (sender, e) => TakePicture();
                rotateBtn.Click += (sender, e) => ChangeCamera();
                flashBtn.Click += (sender, e) => ChandeFlashMode();
                FindViewById<ImageButton>(Resource.Id.closeBtn).Click += (sender, e) => Exit();

                acceptBtn.Click += (sender, e) => ExitWithResult();
                discardBtn.Click += (sender, e) => DiscardChanges();

                mCaptureCallback = new CameraCaptureListener(this);
                mOnImageAvailableListener = new ImageAvailableListener(this, mre);
                mOrientationListener = new SensorOrientationListener(this);
            }
        }
        protected override void OnStart()
        {
            base.OnStart();
            mOrientationListener.Start();
        }
        //private void ChangeOrientation()
        //{
        //    if (fullScreenSize)
        //    {
        //        fullScreenSize = false;
        //        CloseCamera();
        //        OpenCamera(mTextureView.Width, mTextureView.Height);
        //    }
        //    else
        //    {
        //        fullScreenSize = true;
        //        CloseCamera();
        //        OpenCamera(mTextureView.Width, mTextureView.Height);
        //    }
        //}

        protected override void OnResume()
        {
            base.OnResume();
            StartBackgroundThread();

            // When the screen is turned off and turned back on, the SurfaceTexture is already
            // available, and "onSurfaceTextureAvailable" will not be called. In that case, we can open
            // a camera and start preview from here (otherwise, we wait until the surface is ready in
            // the SurfaceTextureListener).
            if (mTextureView.IsAvailable)
            {
                OpenCamera(mTextureView.Width, mTextureView.Height);
            }
            else
            {
                mTextureView.SurfaceTextureListener = mSurfaceTextureListener;
            }
        }
        protected override void OnPause()
        {
            mOrientationListener.Stop();
            CloseCamera();
            StopBackgroundThread();
            base.OnPause();
        }

        // Sets up member variables related to camera.
        private void SetUpCameraOutputs(int width, int height)
        {
            var manager = (CameraManager)GetSystemService(Android.Content.Context.CameraService);
            camerasCount = manager.GetCameraIdList().Length;
            if (camerasCount == 0)
            {
                Finish();
            }
            try
            {
                var cameraId = targetCamera;
                CameraCharacteristics characteristics = manager.GetCameraCharacteristics(cameraId);

                var facing = (Integer)characteristics.Get(CameraCharacteristics.LensFacing);

                var map = (StreamConfigurationMap)characteristics.Get(CameraCharacteristics.ScalerStreamConfigurationMap);

                // For still image captures, we use the largest available size.
                Size largest = (Size)Collections.Max(Arrays.AsList(map.GetOutputSizes((int)ImageFormatType.Jpeg)),
                    new CompareSizesByArea());
                mImageReader = ImageReader.NewInstance(largest.Width, largest.Height, ImageFormatType.Jpeg, 20);
                mImageReader.SetOnImageAvailableListener(mOnImageAvailableListener, mBackgroundHandler);

                // Find out if we need to swap dimension to get the preview size relative to sensor
                // coordinate.
                var displayRotation = WindowManager.DefaultDisplay.Rotation;
               

                Point displaySize = new Point();
                WindowManager.DefaultDisplay.GetSize(displaySize);

                var rotatedPreviewWidth = width;
                var rotatedPreviewHeight = height;
                var maxPreviewWidth = displaySize.X;
                var maxPreviewHeight = displaySize.Y;

               
                if (maxPreviewWidth > MAX_PREVIEW_WIDTH)
                {
                    maxPreviewWidth = MAX_PREVIEW_WIDTH;
                }

                if (maxPreviewHeight > MAX_PREVIEW_HEIGHT)
                {
                    maxPreviewHeight = MAX_PREVIEW_HEIGHT;
                }

              
                fullScreenSize = true;
                mPreviewSize = new Size(displaySize.Y, displaySize.X);
             
                var available = (Boolean)characteristics.Get(CameraCharacteristics.FlashInfoAvailable);
                if (available == null)
                {
                    mFlashSupported = false;
                    mFlashMode = FlashMode.Off;
                }
                else
                {
                    mFlashSupported = (bool)available;

                }

                mCameraId = cameraId;
                return;
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
            catch (Java.Lang.NullPointerException e)
            {
                // Currently an NPE is thrown when the Camera2API is used but not supported on the
                // device this code runs.
                //  ErrorDialog.NewInstance(GetString(Resource.String.camera_error)).Show(ChildFragmentManager, FRAGMENT_DIALOG);
            }
        }

        // Opens the camera specified by {@link ClipperAFragment#mCameraId}.
        public void OpenCamera(int width, int height)
        {
            if (ContextCompat.CheckSelfPermission(this, Manifest.Permission.Camera) != Permission.Granted)
            {
                return;
            }
            SetUpCameraOutputs(width, height);

            ConfigureTransform(width, height);

            var manager = (CameraManager)GetSystemService(Context.CameraService);
            try
            {
                if (!mCameraOpenCloseLock.WaitOne(2500))
                {
                    throw new RuntimeException("Time out waiting to lock camera opening.");
                }
                manager.OpenCamera(mCameraId, mStateCallback, mBackgroundHandler);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException("Interrupted while trying to lock camera opening.", e);
            }
        }

        // Closes the current {@link CameraDevice}.
        private void CloseCamera()
        {
            try
            {
                mCameraOpenCloseLock.WaitOne();
                if (null != mCaptureSession)
                {
                    mCaptureSession.Close();
                    mCaptureSession = null;
                }
                if (null != mCameraDevice)
                {
                    mCameraDevice.Close();
                    mCameraDevice = null;
                }
                if (null != mImageReader)
                {
                    mImageReader.Close();
                    mImageReader = null;
                }
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException("Interrupted while trying to lock camera closing.", e);
            }
            finally
            {
                mCameraOpenCloseLock.Release();
            }
        }

        // Starts a background thread and its {@link Handler}.
        private void StartBackgroundThread()
        {
            mBackgroundThread = new HandlerThread("CameraBackground");
            mBackgroundThread.Start();
            mBackgroundHandler = new Handler(mBackgroundThread.Looper);
        }

        // Stops the background thread and its {@link Handler}.
        private void StopBackgroundThread()
        {
            mBackgroundThread.QuitSafely();
            try
            {
                mBackgroundThread.Join();
                mBackgroundThread = null;
                mBackgroundHandler = null;
            }
            catch (InterruptedException e)
            {
                e.PrintStackTrace();
            }
        }

        // Creates a new {@link CameraCaptureSession} for camera preview.
        public void CreateCameraPreviewSession()
        {
            try
            {
                SurfaceTexture texture = mTextureView.SurfaceTexture;
                if (texture == null)
                {
                    throw new IllegalStateException("texture is null");
                }

                // We configure the size of default buffer to be the size of camera preview we want.
                texture.SetDefaultBufferSize(mPreviewSize.Width, mPreviewSize.Height);

                // This is the output Surface we need to start preview.
                Surface surface = new Surface(texture);

                // We set up a CaptureRequest.Builder with the output Surface.
                mPreviewRequestBuilder = mCameraDevice.CreateCaptureRequest(CameraTemplate.Preview);
                mPreviewRequestBuilder.AddTarget(surface);

                // Here, we create a CameraCaptureSession for camera preview.
                List<Surface> surfaces = new List<Surface>();
                surfaces.Add(surface);
                surfaces.Add(mImageReader.Surface);
                mCameraDevice.CreateCaptureSession(surfaces, new CameraCaptureSessionCallback(this), null);

            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }

        public static T Cast<T>(Java.Lang.Object obj) where T : class
        {
            var propertyInfo = obj.GetType().GetProperty("Instance");
            return propertyInfo == null ? null : propertyInfo.GetValue(obj, null) as T;
        }       

        // Configures the necessary {@link android.graphics.Matrix}
        // transformation to `mTextureView`.
        // This method should be called after the camera preview size is determined in
        // setUpCameraOutputs and also the size of `mTextureView` is fixed.

        public void ConfigureTransform(int viewWidth, int viewHeight)
        {
            if (null == mTextureView || null == mPreviewSize)
            {
                return;
            }
            var rotation = (int)WindowManager.DefaultDisplay.Rotation;
            Matrix matrix = new Matrix();
            RectF viewRect = new RectF(0, 0, viewWidth, viewHeight);
            RectF bufferRect = new RectF(0, 0, mPreviewSize.Height, mPreviewSize.Width);
            float centerX = viewRect.CenterX();
            float centerY = viewRect.CenterY();
            if ((int)SurfaceOrientation.Rotation90 == rotation || (int)SurfaceOrientation.Rotation270 == rotation)
            {
                bufferRect.Offset(centerX - bufferRect.CenterX(), centerY - bufferRect.CenterY());
                matrix.SetRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.Fill);
                float scale = System.Math.Max((float)viewHeight / mPreviewSize.Height, (float)viewWidth / mPreviewSize.Width);
                matrix.PostScale(scale, scale, centerX, centerY);
                matrix.PostRotate(90 * (rotation - 2), centerX, centerY);
            }
            else if ((int)SurfaceOrientation.Rotation180 == rotation)
            {
                matrix.PostRotate(180, centerX, centerY);
            }
            mTextureView.SetTransform(matrix);
        }

        // Initiate a still image capture.
        private void TakePicture()
        {
            LockFocus();

            mTextureView.Visibility = ViewStates.Gone;
            mImageView.Visibility = ViewStates.Visible;

            rotateBtn.Visibility = ViewStates.Gone;
            takePictureBtn.Visibility = ViewStates.Gone;
            flashBtn.Visibility = ViewStates.Gone;

            acceptBtn.Visibility = ViewStates.Visible;
            discardBtn.Visibility = ViewStates.Visible;

            mre.WaitOne();
            Glide.With(this).Load(mOnImageAvailableListener.PostResult).Into(mImageView);

            mre.Reset();
        }

        // Lock the focus as the first step for a still image capture.
        private void LockFocus()
        {
            try
            {
                // This is how to tell the camera to lock focus.

                mPreviewRequestBuilder.Set(CaptureRequest.ControlAfTrigger, (int)ControlAFTrigger.Start);
                // Tell #mCaptureCallback to wait for the lock.
                mState = STATE_WAITING_LOCK;
                mCaptureSession.Capture(mPreviewRequestBuilder.Build(), mCaptureCallback,
                        mBackgroundHandler);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }

        // Run the precapture sequence for capturing a still image. This method should be called when
        // we get a response in {@link #mCaptureCallback} from {@link #lockFocus()}.
        public void RunPrecaptureSequence()
        {
            try
            {
                // This is how to tell the camera to trigger.
                mPreviewRequestBuilder.Set(CaptureRequest.ControlAePrecaptureTrigger, (int)ControlAEPrecaptureTrigger.Start);
                // Tell #mCaptureCallback to wait for the precapture sequence to be set.
                mState = STATE_WAITING_PRECAPTURE;
                mCaptureSession.Capture(mPreviewRequestBuilder.Build(), mCaptureCallback, mBackgroundHandler);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }

        private CaptureRequest.Builder stillCaptureBuilder;

        // Capture a still picture. This method should be called when we get a response in
        // {@link #mCaptureCallback} from both {@link #lockFocus()}.
        public void CaptureStillPicture()
        {
            try
            {
                if (null == mCameraDevice)
                {
                    return;
                }
                // This is the CaptureRequest.Builder that we use to take a picture.
                
                stillCaptureBuilder = mCameraDevice.CreateCaptureRequest(CameraTemplate.StillCapture);

                stillCaptureBuilder.AddTarget(mImageReader.Surface);

                // Use the same AE and AF modes as the preview.
                stillCaptureBuilder.Set(CaptureRequest.ControlAfMode, (int)ControlAFMode.ContinuousPicture);
                SetFlash(stillCaptureBuilder);

                // Orientation
                int rotation = (int)WindowManager.DefaultDisplay.Rotation;
                var orient = GetOrientation(rotation);
                stillCaptureBuilder.Set(CaptureRequest.JpegOrientation, orient);

                mCaptureSession.StopRepeating();
                mCaptureSession.Capture(stillCaptureBuilder.Build(), new CameraCaptureStillPictureSessionCallback(this), null);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }

        // Retrieves the JPEG orientation from the specified screen rotation.
        private int GetOrientation(int rotation)
        {
            // Sensor orientation is 90 for most devices, or 270 for some devices (eg. Nexus 5X)
            // We have to take that into account and rotate JPEG properly.
            // For devices with orientation of 90, we simply return our mapping from ORIENTATIONS.
            // For devices with orientation of 270, we need to rotate the JPEG 180 degrees.
            return (ORIENTATIONS.Get(rotation) + (int)mSensorOrientation + 270) % 360;
        }

        // Unlock the focus. This method should be called when still image capture sequence is
        // finished.
        public void UnlockFocus()
        {
            try
            {
                // Reset the auto-focus trigger
                mPreviewRequestBuilder.Set(CaptureRequest.ControlAfTrigger, (int)ControlAFTrigger.Cancel);
                SetFlash(mPreviewRequestBuilder);
                mCaptureSession.Capture(mPreviewRequestBuilder.Build(), mCaptureCallback,
                        mBackgroundHandler);
                // After this, the camera will go back to the normal state of preview.
                mState = STATE_PREVIEW;
                mCaptureSession.SetRepeatingRequest(mPreviewRequest, mCaptureCallback,
                        mBackgroundHandler);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }

        public void SetFlash(CaptureRequest.Builder requestBuilder)
        {
            if (mFlashSupported)
            {
                ControlAEMode sysFlashMode = 0;
                switch (mFlashMode)
                {
                    case FlashMode.On:
                        flashBtn.Background = GetDrawable(Resource.Drawable.outline_flash_auto_24);
                        sysFlashMode = ControlAEMode.On;
                        break;
                    case FlashMode.Off:
                        flashBtn.Background = GetDrawable(Resource.Drawable.outline_flash_off_24);
                        sysFlashMode = ControlAEMode.Off;
                        break;
                    case FlashMode.Auto:
                        flashBtn.Background = GetDrawable(Resource.Drawable.outline_flash_on_24);
                        sysFlashMode = ControlAEMode.OnAutoFlash;
                        break;
                    default:
                        break;
                }
                requestBuilder.Set(CaptureRequest.ControlAeMode, (int)ControlAEMode.On);
                requestBuilder.Set(CaptureRequest.FlashMode, (int)sysFlashMode);

            }
        }

        private static Size ChooseOptimalSize(Size[] choices, int textureViewWidth,
           int textureViewHeight, int maxWidth, int maxHeight, Size aspectRatio)
        {
            // Collect the supported resolutions that are at least as big as the preview Surface
            var bigEnough = new List<Size>();
            // Collect the supported resolutions that are smaller than the preview Surface
            var notBigEnough = new List<Size>();
            int w = aspectRatio.Width;
            int h = aspectRatio.Height;

            for (var i = 0; i < choices.Length; i++)
            {
                Size option = choices[i];
                if ((option.Width <= maxWidth) && (option.Height <= maxHeight) &&
                       option.Height == option.Width * h / w)
                {
                    if (option.Width >= textureViewWidth &&
                        option.Height >= textureViewHeight)
                    {
                        bigEnough.Add(option);
                    }
                    else
                    {
                        notBigEnough.Add(option);
                    }
                }
            }
            // Pick the smallest of those big enough. If there is no one big enough, pick the
            // largest of those not big enough.
            if (bigEnough.Count > 0)
            {
                return (Size)Collections.Min(bigEnough, new CompareSizesByArea());
            }
            else if (notBigEnough.Count > 0)
            {
                return (Size)Collections.Max(notBigEnough, new CompareSizesByArea());
            }
            else
            {
                Log.Error(TAG, "Couldn't find any suitable preview size");
                return choices[0];
            }
        }
        private void Exit()
        {
            CloseCamera();
            Finish();
        }
        
        private void ExitWithResult()
        {
            Intent intent = new Intent();
            intent.PutExtra("imagePath", mOnImageAvailableListener.PostResult.AbsolutePath);
            SetResult(Result.Ok, intent);
            Finish();
        }

        private void ChangeCamera()
        {
            int currCamera = int.Parse(targetCamera);
            if (camerasCount > 1)
            {
                StopBackgroundThread();
                CloseCamera();

               
                if (currCamera + 1 != camerasCount)
                {
                    targetCamera = (currCamera + 1).ToString();
                }
                else
                {
                    targetCamera = "0";
                }

                mCaptureCallback = new CameraCaptureListener(this);
                mOnImageAvailableListener = new ImageAvailableListener(this, mre);

                if (int.Parse(targetCamera) == 1)
                    isFaceCamera = true;
                else
                    isFaceCamera = false;
                StartBackgroundThread();
                OpenCamera(mTextureView.Width, mTextureView.Height);
            }
        }

        private void ChandeFlashMode()
        {
            if(mFlashSupported)
            {
                int flashEnumCount = FlashMode.GetNames(typeof(FlashMode)).Length;

                int currentMode = (int)mFlashMode;

                if(currentMode + 1 == flashEnumCount)
                {
                    mFlashMode = 0;
                }
                else
                {
                    mFlashMode = (FlashMode)(currentMode + 1);
                }
                CloseCamera();
                OpenCamera(mTextureView.Width, mTextureView.Height);
            }
            else
            {
                Toast.MakeText(this, "This camera doesn`t have an itegrated flashlight", ToastLength.Short);
            }
        }
        private void DiscardChanges()
        {
            mTextureView.Visibility = ViewStates.Visible;
            mImageView.Visibility = ViewStates.Gone;

            acceptBtn.Visibility = ViewStates.Gone;
            discardBtn.Visibility = ViewStates.Gone;

            rotateBtn.Visibility = ViewStates.Visible;
            takePictureBtn.Visibility = ViewStates.Visible;
            flashBtn.Visibility = ViewStates.Visible;
        }

        public void OrientationChanged()
        {
            float rotDeg = 0;
            bool isLandscape = false;
            switch (mSensorOrientation)
            {
                case ImageOrientation.Portrait:
                    break;
                case ImageOrientation.LandscapeLeft:
                    rotDeg = 90;
                    isLandscape = true;
                    break;
                case ImageOrientation.LandscapeRight:
                    rotDeg = 270;
                    isLandscape = true;
                    break;
                case ImageOrientation.PortraitBottom:
                    rotDeg = 180;
                    break;
                default:
                    break;
            }
            if (mTextureView.Visibility == ViewStates.Visible)
            {
                rotateBtn.Rotation = rotDeg;
                flashBtn.Rotation = rotDeg;
            }
            else
            {
                acceptBtn.Rotation = rotDeg;
                mImageView.Rotation = rotDeg;

                if (isLandscape)
                {
                    mImageView.Rotation = (rotDeg);
                }
            }
        }
    }
}
