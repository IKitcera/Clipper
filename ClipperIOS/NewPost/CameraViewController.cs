// This file has been autogenerated from a class added in the UI designer.

using System;

using Foundation;
using UIKit;
using AVFoundation;
using CoreFoundation;
using CoreMedia;
using CoreImage;
using System.Collections.Generic;

namespace ClipperIOS
{
	public partial class CameraViewController : UIViewController//, IAVCaptureVideoDataOutputSampleBufferDelegate
	{
        public bool CameraPermisiion;
        public bool takePicture = false;
        public string userId { get; set; }

        private AVCaptureSession captureSession;

        private AVCaptureDevice backCamera;
        private AVCaptureDevice frontCamera;

        private AVCaptureInput frontInput;
        private AVCaptureInput backInput;

        private AVCaptureVideoPreviewLayer previewLayer;
        private AVCaptureStillImageOutput imageOutput;

        bool backCameraOn;
        public CameraViewController (IntPtr handle) : base (handle)
		{
		}

        #region Lifecycle
        public override void ViewDidLoad()
        {
            base.ViewDidLoad();

            backBtn.TouchUpInside += (sender, e) => DismissViewController(false, null);
            takePictureBtn.TouchUpInside += (sender, e) => Capture();
            rotateCameraBtn.TouchUpInside += (sender, e) => SwitchCameraInput();
            lightBtn.TouchUpInside += (sender, e) => SwitchFlashIfCould();
         }

        public override void ViewWillAppear(bool animated)
        {
            base.ViewDidAppear(animated);

            //Check for permission first
            if (CheckPermission())
            {
                SetupAndStartCameraSession();
                notAvailableLabel.Hidden = true;
            }
            else
                notAvailableLabel.Hidden = false;
        }

        public override void ViewWillDisappear(bool animated)
        {
            if(captureSession.Running)
                captureSession.StopRunning();
            base.ViewWillDisappear(animated);
        }
        #endregion

        #region Methods

        private bool CheckPermission()
        {
            var permission = AVCaptureDevice.GetAuthorizationStatus(AVAuthorizationMediaType.Video);

            bool returningPermission = false;
            if (!CameraPermisiion)
            {
                if (permission == AVAuthorizationStatus.NotDetermined ||
                    permission == AVAuthorizationStatus.Denied)
                        AVCaptureDevice.RequestAccessForMediaType(AVAuthorizationMediaType.Video, p =>
                        {
                            if (p)
                                returningPermission = true;
                        });
                else
                    returningPermission = true;
            }
            else
                returningPermission = true;
            return returningPermission;
        }

        private void SetupAndStartCameraSession()
        {
            DispatchQueue.DefaultGlobalQueue.DispatchAsync(() =>
            {
                captureSession = new AVCaptureSession();
                captureSession.BeginConfiguration();

                // do some configs
                if (captureSession.CanSetSessionPreset(new NSString("photo")))
                    captureSession.SessionPreset = new NSString("photo");
                captureSession.AutomaticallyConfiguresCaptureDeviceForWideColor = true;

                SetupInputs();

                BeginInvokeOnMainThread(() => SetupPreviewLayer());

                SetupOutput();

                captureSession.CommitConfiguration();
                captureSession.StartRunning();

            });
        }
        private void SetupInputs()
        {

            frontCamera = AVCaptureDevice.GetDefaultDevice(AVCaptureDeviceType.BuiltInWideAngleCamera, AVMediaTypes.Video, AVCaptureDevicePosition.Front);
            backCamera = AVCaptureDevice.GetDefaultDevice(AVCaptureDeviceType.BuiltInWideAngleCamera, AVMediaTypes.Video, AVCaptureDevicePosition.Back);

            try
            {
                NSError inputError = new NSError();

                var input = new AVCaptureDeviceInput(frontCamera, out inputError);

                if(input != null)
                {
                    frontInput = input;
                }

                input = new AVCaptureDeviceInput(backCamera, out inputError);

                if (input != null)
                {
                    backInput = input;
                }

                if (captureSession.CanAddInput(backInput))
                {
                     captureSession.AddInput(backInput);
                    backCameraOn = true;
                }
                else
                {
                    if (captureSession.CanAddInput(frontInput))
                    {
                        captureSession.AddInput(frontInput);
                        backCameraOn = false;
                    }
                }
            }
            catch 
            {
                BeginInvokeOnMainThread(() =>
                {
                    notAvailableLabel.Hidden = false;
                    lightBtn.Enabled = false;
                    rotateCameraBtn.Enabled = false;
                    takePictureBtn.Enabled = false;
                });
            }
        }

        private void SetupOutput()
        {
            imageOutput = new AVCaptureStillImageOutput();

            if (captureSession.CanAddOutput(imageOutput))
                captureSession.AddOutput(imageOutput);
            else
                notAvailableLabel.Hidden = false;
        }

        private void SetupPreviewLayer()
        {
            previewLayer = new AVCaptureVideoPreviewLayer(captureSession);

            if(View.Layer.Sublayers[0].GetType() != previewLayer.GetType())
                View.Layer.InsertSublayer(previewLayer, 0);
            else
                View.Layer.ReplaceSublayer(View.Layer.Sublayers[0], previewLayer);

            previewLayer.Frame = View.Layer.Frame;
        }

        private void Capture()
        {
           takePicture = true;


            var connection = imageOutput.ConnectionFromMediaType(new NSString(AVMediaType.Video.ToString()));

            var orientation = (int)UIDevice.CurrentDevice.Orientation;
            
            connection.VideoOrientation = (AVCaptureVideoOrientation)orientation;

            imageOutput.CaptureStillImageAsynchronously(connection, (buff, error) =>
            {
                if (error == null)
                {
                    var imageData = AVCaptureStillImageOutput.JpegStillToNSData(buff);
                    NSDictionary metaData = buff.GetAttachments(CMAttachmentMode.ShouldPropagate);

                    var image = new UIImage(imageData);

                    if (image != null)
                    {
                        ShowPostView(image);
                    }
                }
            });

        }

        private void SwitchCameraInput()
        {
            rotateCameraBtn.UserInteractionEnabled = false ;
            captureSession.BeginConfiguration();

            if (backCameraOn)
            {
                captureSession.RemoveInput(backInput);
                captureSession.AddInput(frontInput);
                backCameraOn = false;
            }
            else
            {
                captureSession.RemoveInput(frontInput);
                captureSession.AddInput(backInput);
                backCameraOn = true;
            }
            captureSession.CommitConfiguration();

            rotateCameraBtn.UserInteractionEnabled = true;
        }

        private void SwitchFlashIfCould()
        {
            if (backCameraOn)
            {
                if (!CheckCameraOnFlashExistanceAndSwitch(backCamera))
                {
                    (this as UIViewController).ShowToast("Could not find the flashlight", 3);
                }
                else
                {
                    var error = new NSError();
                    captureSession.RemoveInput(backInput);

                    backInput = new AVCaptureDeviceInput(backCamera, out error);
                    if (captureSession.CanAddInput(backInput))
                        captureSession.AddInput(backInput);
                }
            }
            else
            {
                if (!CheckCameraOnFlashExistanceAndSwitch(frontCamera))
                {
                    (this as UIViewController).ShowToast("Could not find the flashlight", 3);
                }
                else
                {
                    var error = new NSError();
                    captureSession.RemoveInput(frontInput);

                    frontInput = new AVCaptureDeviceInput(frontCamera, out error);
                    if (captureSession.CanAddInput(frontInput))
                        captureSession.AddInput(frontInput);
                }
            }
        }

        private bool CheckCameraOnFlashExistanceAndSwitch(AVCaptureDevice camera)
        {
            if (camera.HasFlash)
             {
                    try
                    {
                        NSError error = new NSError();
                        camera.LockForConfiguration(out error);

                        var currentFlashMode = (int)camera.FlashMode;
                        var modesCount = Enum.GetNames(typeof(AVCaptureFlashMode)).Length;

                        if (currentFlashMode + 1 < modesCount)
                            camera.FlashMode = (AVCaptureFlashMode)(currentFlashMode + 1);
                        else
                            camera.FlashMode = (AVCaptureFlashMode)0;

                        camera.UnlockForConfiguration();

                        return true;
                    }
                    catch
                    {
                        return false;
                    }
                    finally
                    {
                        camera.UnlockForConfiguration();
                    }
            }
                return false;
        }

       private void ShowPostView(UIImage img)
        {
            BeginInvokeOnMainThread(() =>
            {
                var editController = Storyboard.InstantiateViewController("EditingPostController") as EditingPostViewController;
                editController.images = new List<UIImage> { img };
                editController.userId = userId;

                takePicture = false;
                ShowViewController(editController, this);
            });
        }

        /*
        private void DisposeSources()
        {
            IDisposable[] toDispose =
            { captureSession,
              previewLayer,
              imageOutput };

            for(int i = 0; i < toDispose.Length; i++)
            {
                toDispose[i].Dispose();
                toDispose[i] = null;
            }
        }
        */
        #endregion
    }
}
